# 正则表达式

> 作者：shensr 
>
> 时间: 2020-04-03

### 创建正则表达式

正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作。

正则表达式所支持的合法字符

| 表达式 | 含义                                                         |
| ------ | :----------------------------------------------------------- |
| x      | 指定字符x（x可代表任何合法的字符）                           |
| \0mnn  | 八进制0mnn所表示 的字符                                      |
| \xhh   | 十六进制 0xhh 所表示的字符                                   |
| \uhhhh | 十六进制 0xhhhh所表示 的 Unicode 字符                        |
| \t     | 制表符 Tab（"\u0009"）                                       |
| \n     | 换行符（"\u000A"）                                           |
| \r     | 回车符（"\u000D"）                                           |
| \f     | 换页符（"\u000C"）                                           |
| \e     | 转义（ Escape）                                              |
| \cx    | x对应的控制符。例如：\cM匹配 ctrl-M，x的值必须为A\~ Z 或 a\~z之一 |

正则表达式中的特殊字符，**如果要匹配这些特殊字符，就必须首先将这些字符转义**，即在前面添加一个`反斜杠（\）`

| 特殊字符 | 含义                                                         |
| -------- | :----------------------------------------------------------- |
| $        | 匹配一行的结尾。要匹配`$`字符本身，请使用 \\$                |
| ^        | 匹配一行的开头。要匹配`^`字符本身，请使用 \\^                |
| ()       | 标记子表达式的开始和结束位置。要匹配这些字符，请使用`\(`和`\)` |
| []       | 用于确定中括号表达式的开始和结束位置。                       |
| {}       | 用于标记前面子表达式的出现频度。                             |
| *        | 指定前面子表达式可以出现**零次或多次**。                     |
| +        | 指定前面子表达式可以出现**一次或多次**。                     |
| ?        | 指定前面子表达式可以出现**零次或一次**。                     |
| .        | 匹配出换行符`\n`以外的任何字符。                             |
| \        | 用于转义下一个字符，或指定八进制、十六进制字符。             |
| \|       | 指定两项之间任选一项，表示“或”。                             |

例子：

```text
\\u0041\\        => 匹配a\
\\0101\t         => 匹配a<制表符>
\?\[             => 匹配?[
```

正则表达式中预定义字符

| 预定义字符 | 含义                                                         |
| ---------- | :----------------------------------------------------------- |
| .          | 可以匹配任何字符                                             |
| \d         | 匹配0\~9的所有数字                                           |
| \D         | 匹配非数字                                                   |
| \s         | 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 |
| \S         | 匹配所有的非空白字符                                         |
| \w         | 匹配所有的单词字符，包括0\~9所有数字、26个英文字母和下划线（_） |
| \W         | 匹配所有的非单词字符                                         |


> **提示：**
> 上面的7个预定义字符其实很容易记忆——d是digit的意思，代表数字；s是space的意思，代表空白；w是word的意思，代表单词。d、s、w的大写形式恰好匹配与之相反的字符。

例子：

```text
c\wt  					//可以匹配cat、cbt、cct、c0t、c9t等一批字符串 
\d\d\d-\d\d\d-\d\d\d\d  //匹配如000-000-0000形式的电话号码
```

正则表达式中方括号表达式



| 方括号表达式     | 含义                                                         |
| ---------------- | :----------------------------------------------------------- |
| 表示枚举         | 例如[abc]，表示a、b、c其中的任意一个字符，                   |
| 表示范围：-      | 例如[a-f]，表示a\~f范围内的任意字符                          |
| 表示求否：^      | 例如[\^abc]，表示非a、b、c的任意字符，[\^a-f]表示不是a\~f范围内的任意字符 |
| 表示“与”运算：&& | 例如[a-z&&[def]],求a\~z和[def]的交集，即表示d、e或f          |
| 表示“并”运算     | 并运算和前面的枚举类似。例如[a-d[m-p]]，表示[a-dm-p]         |

> **提示：**
  方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用[\\\u0041-\\\u0056]形式——因为所有中文字符的Unicode值是连续的，只要找出所有中文字符中最小、最大的Unicode值，就可以利用上面形式来匹配所有的中文字符。

Java正在表达式还支持边界匹配符

| 边界匹配符 | 含义         | 边界匹配符 | 含义                           |
| ---------- | ------------ | ---------- | ------------------------------ |
| ^          | 行的开头     | \A         | 输入的开头                     |
| $          | 行的结尾     | \G         | 前一个匹配的结尾               |
| \b         | 单词的边界   | \Z         | 输入的结尾，仅用于最后的结束符 |
| \B         | 非单词的边界 | \z         | 输入的结尾                     |

正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。

-  Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为——你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。

- Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。

- Possessive（占有模式）：用加号后缀（+）表示，目前只有Java支持占有模式，通常比较少用。

| 贪婪型 | 勉强型  | 占有型  | 如何匹配                  |
| ------ | ------- | ------- | ------------------------- |
| X?     | X??     | X?+     | 一个或零个 X              |
| X*     | X*?     | X*+     | 零个或多个 X              |
| X+     | X+?     | X++     | 一个或多个 X              |
| X{n}   | X{n}?   | X{n}+   | 恰好 n 次 X               |
| X{n,}  | X{n,}?  | X{n,}+  | 至少 n 次 X               |
| X{n,m} | X{n,m}? | X{n,m}+ | X至少 n 次，但不超过 m 次 |



### 使用正则表达式

一旦在程序中定义了正则表达式，就可以使用`Pattern`和`Matcher`来使用正则表达式。
`Pattern`对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为`Pattern`对象，然后再利用该`Pattern`对象创建对应的`Matcher`对象。执行匹配所涉及的状态保留在`Matcher`对象中，多个`Matcher`对象可共享同一个`Pattern`对象。
因此，典型的调用顺序如下：

```java
//将一个字符串编译成Pattern对象       
Pattern p=Pattern.compile("a*b"); 
//使用Pattern对象创建Matcher对象 
Matcher m=p.matcher("aaaaab"); 
boolean b=m.matches(); //返回true
```

上面定义的Pattern对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用Pattern类的静态matches方法，此方法自动把指定字符串编译成匿名的Pattern对象，并执行匹配，如下所示。

```java
 boolean b=Pattern.matches("a*b", "aaaaab");  //返回true
```

上面语句等效于前面的三条语句。但采用这种语句每次都需要重新编译新的Pattern对象，不能重复利用已编译的Pattern对象，所以效率不高。
Pattern是不可变类，可供多个并发线程安全使用。

!> **注意：**
在Pattern、Matcher类的介绍中经常会看到一个CharSequence接口，该接口代表一个字符序列，其中CharBuffer、String、StringBuffer、StringBuilder都是它的实现类。简单地说，CharSequence代表一个各种表示形式的字符串。